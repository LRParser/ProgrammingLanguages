Group #9 Assignment #2
	Jon Boone
	Joshua Datko
	Paul DeMicco
	Joseph Heenan
________________

This package contains all of the files for Assignment #2.

=======
interpreterext.py

** Contains the grammar for the original mini language along with


programext.py

** Contains the implementation for the grammar.


makefile

view —
    display (using the more utility) all of your source code

compile-static —
    Does whatever you need to do to get ready to run your statically-bound
    interpreter (even if it's nothing)

compile-dynamic —
    Does whatever you need to do to get ready to run your statically-bound
    interpreter (even if it's nothing)

run-static —
    Run your statically-bound interpreter, which will read from stdin

run-dynamic —
    Run your dynamically-bound interpreter, which will read from stdin

clean —
    remove all binaries and intermediate files


TEST FILES - Will be explained in detail below:


DESCRIPTION: Assignment #6
-------------------------------------------------------------------------------


Modify the mini language grammar, parser and interpreter to treat Proc as an
expression so that it can be assigned to variables, passed as an argument, and
returned as a function value. You must support nested procedures and should use
a list of environments to resolve variable references. You wil need to
implement two versions of your interpreter: 1) using static scope, and 2) using
dynamic scope. You must test your interpreters with mini language programs that
have a nested procedure, a procedure that passes a procedure as an argument, a
procedure that returns a procedure, and atleast one example where you get
different results using static and dynamic scoping.



makefile breakdown
-------------------------------------------------------------------------------


make view:
---------

This will view the source files for both parts.  Dynamic scoping code lives in
the same source file and is controlled with a command line switch.

make compile-static
make compile-dynamic
--------------------

These are NoOps and just do a "clean"

make run-static
---------------

Will wait for input from stdint.  We tested by redirecting stdin from a test
file like so:

make run-static < testfile

make run-dynamic
----------------

This is equivalent to running "python interpreterext.py --dynamic-scope", but
with less typing.  Similar to run-static, it's best if you run the program like
so:

make run-dynamic < testfile

This will evaluate the mini-language program with dynamic scoping rules.

make clean
----------

removes intermediary output files.

make test
---------

Runs all the tests described below.

-------------------------------------------------------------------------------

TESTING: Assignment #2, Part #1
___________
All test case files (*.p) have been run through the interpreters to ensure proper operation.


VIEWING FUNCTIONS: Assignment #2, Part #3, Length Functions
__________

The following makefile targets are supported:

view-func1: This will show the iterative length function in the mini language. This function was built using the sample code posted by instructor on the Discussion board, with modified test data

view-func2: This will show the recursive length function in the mini language. This function was build using the sample code posted by instructor on the Discussion board, with modified test data


DESCRIPTION: Assignment #2, Part #2
___________

Part 2 of the project implements the same extensions to the mini languange however it implements dynamic memory allocation and
garbage collection using the following:

	All memory allocation is done using the cons function call.  This provides a heap of cons cells and organizes them in a list. Cons, car, cdr and nullp
	have been reimplemented to access cells located in the heap.

	Gabage collection is implemented using a mark and sweep algorithm.

RUNNING: Assignment #2, Part #2
___________

Can be run via make run-part2 < myinputfile (where you substitute myinputfile for an appropriate mini language input file)

TESTING: Assignment #2, Part #2
___________
All test case files (*.p) have been run through the interpreters to ensure proper operation.
