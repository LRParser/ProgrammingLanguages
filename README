Group #9 Assignment #6
	Jon Boone
	Joshua Datko
	Paul DeMicco
	Joseph Heenan
________________

=======
interpreterext.py

Contains the grammar for the original mini language.  The syntax change was to
change the define statement to:

'define_stmt : DEFINE IDENT proc'

from:

'define_stmt : DEFINE IDENT PROC LPAREN param_list RPAREN stmt_list END'

programext.py

Implements functions as first class citizens in the mini-language.  The major
high level features were implemented:

* Removed the function table.  Since functions are now first class, they are
  treated as variables.
* Lexical scoping: we extend the environment in the "apply" function by
  creating a new name table and binding the parameters with the evaluated
  arguments for that particular function.
* Assign Statements were modified to add Procs to the name table directly.
* Dynamic scoping: In "apply" we use the caller's environment to bind the
  parameters and arguments instead of extending the environment.

func_globals.py

Global variable to keep track of what scoping rules are in play.


makefile

view —
    display (using the more utility) all of your source code

compile-static —
    Does whatever you need to do to get ready to run your statically-bound
    interpreter (even if it's nothing)

compile-dynamic —
    Does whatever you need to do to get ready to run your statically-bound
    interpreter (even if it's nothing)

run-static —
    Run your statically-bound interpreter, which will read from stdin

run-dynamic —
    Run your dynamically-bound interpreter, which will read from stdin

clean —
    remove all binaries and intermediate files


TEST FILES - Will be explained in detail below:


DESCRIPTION: Assignment #6
-------------------------------------------------------------------------------


Modify the mini language grammar, parser and interpreter to treat Proc as an
expression so that it can be assigned to variables, passed as an argument, and
returned as a function value. You must support nested procedures and should use
a list of environments to resolve variable references. You wil need to
implement two versions of your interpreter: 1) using static scope, and 2) using
dynamic scope. You must test your interpreters with mini language programs that
have a nested procedure, a procedure that passes a procedure as an argument, a
procedure that returns a procedure, and atleast one example where you get
different results using static and dynamic scoping.



makefile breakdown
-------------------------------------------------------------------------------


make view:
---------

This will view the source files for both parts.  Dynamic scoping code lives in
the same source file and is controlled with a command line switch.

make compile-static
make compile-dynamic
--------------------

These are NoOps and just do a "clean"

make run-static
---------------

Will wait for input from stdint.  We tested by redirecting stdin from a test
file like so:

make run-static < testfile

make run-dynamic
----------------

This is equivalent to running "python interpreterext.py --dynamic-scope", but
with less typing.  Similar to run-static, it's best if you run the program like
so:

make run-dynamic < testfile

This will evaluate the mini-language program with dynamic scoping rules.

make clean
----------

removes intermediary output files.

make test
---------

Runs all the tests described below.

make view-tests
---------------

Conveniently view all test files.

-------------------------------------------------------------------------------

TESTING:


All test case files (*.p) have been run through the interpreters to ensure
proper operation.


static_tests/add1Func.p:

Tests assigning a function to a variable and then invoking said variable with a
function call.

static_tests/func_param1.p:

Tests passing a function as a parameter and invoking said function in the new
function.

static_tests/makeAdder.p:

Tests nested functions and returning functions from other functions.

static_tests/nestedFuncs.p:

Tests successive function calls from functions assigned to variables.

dyn_tests/add1.p:

Uses dynamic scope to implement a function that will result in an unbound
variable if using static scope.  (i.e. only works dynamically.)

dyn_tests/static_dynamic.p:

A program with two different results in the two approaches (specifically the
"b" is different).
