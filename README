Group #9 Extra Credit Assignment
	Jon Boone
	Joshua Datko
	Paul DeMicco
	Joseph Heenan
________________

=======
interpreterext.py

Contains the grammar for the modified mini language.  The syntax
change was to add class defintion, both with and without single
inheritance, and method call functionality. 


programext.py

Implements class defintion and method calls in the mini-language.  The
major high level features were implemented:

* Created class object entries in the global name table.
* Defined class-specific name table to hold class variables and
  methods. 

func_globals.py

Global variable to keep track of what scoping rules are in play.  Left
over from assignment 6. 


makefile

view-semantics --
    description of syntax and semantics

view-implementation --
    description of implementation

view-tests --
    document describing the test inputs
    
view-code —
    display (using the more utility) all of your source code

run-static —
    Run your statically-bound interpreter, which will read from stdin

clean —
    remove all binaries and intermediate files


TEST FILES - Will be explained in detail below:


DESCRIPTION: Assignment #6
-------------------------------------------------------------------------------


Modify the mini language grammar, parser and interpreter to treat Proc as an
expression so that it can be assigned to variables, passed as an argument, and
returned as a function value. You must support nested procedures and should use
a list of environments to resolve variable references. You wil need to
implement two versions of your interpreter: 1) using static scope, and 2) using
dynamic scope. You must test your interpreters with mini language programs that
have a nested procedure, a procedure that passes a procedure as an argument, a
procedure that returns a procedure, and atleast one example where you get
different results using static and dynamic scoping.



makefile breakdown
-------------------------------------------------------------------------------


make view:
---------

This will view the source files for both parts.  Dynamic scoping code lives in
the same source file and is controlled with a command line switch.

make compile-static
make compile-dynamic
--------------------

These are NoOps and just do a "clean"

make run-static
---------------

Will wait for input from stdint.  We tested by redirecting stdin from a test
file like so:

make run-static < testfile

make run-dynamic
----------------

This is equivalent to running "python interpreterext.py --dynamic-scope", but
with less typing.  Similar to run-static, it's best if you run the program like
so:

make run-dynamic < testfile

This will evaluate the mini-language program with dynamic scoping rules.

make clean
----------

removes intermediary output files.

make test
---------

Runs all the tests described below.

make view-tests
---------------

Conveniently view all test files.

-------------------------------------------------------------------------------

TESTING:


The following test case files (*.p) have been run through the interpreters to ensure
proper operation.


class_tests/class_list.p

Tests creation of a list class, the creation of an instance of the
list class, as well as the invocation of a method of the class. 

